Flood It!
By: Nandha Gopikannan and Chris Haleas

Questions:

1. What function roughly fits that graph?
The function that fits the graph is f(n) = n. Despite there being some inconsistencies, the graph largely aligns with f(n) = n.

2. What is the time complexity of your flood() function based on analyzing its code?
Based on analyzing our flood() code, the time complexity is O(n). The first step was initializing the linked list and the array. These initializations have a time complexity of O(1). The next step is a for loop that initializes coordinates to the linked list. The for loop linearly iterated through flooded_list, which would have an O(n) time complexity. The next step is the while loop that runs until the linked list is empty. In this while loop, the first element of the linked list is removed, which has an O(1) time complexity. Then, there is a for loop that loops through the tile coordinates to see if they have been visited. If they have not, they are flooded and marked as visited, and the neighboring coordinates are added to flooded_list and queue. This has an O(1) time complexity because there is always a constant number of neighbors to any given coordinate. The for loop has an O(1) time complexity as this is the worst case within it. The overall while loop also has an O(1) time complexity as all of its pieces are O(1). The worst time complexity among all of the code's pieces is O(n), therefore this is the overall time complexity. This is a linear function, making it f(n) = n.

3. Does your analysis match up with what you see in the graph?
The analysis does match with the graph, as the graph shows a linear function -> f(n) = n. The time complexity concluded from our analysis is O(n), which is a linear function.

4. What data structures did you use (linked lists, arrays…) ? Is the time complexity of your flood function the best it can be or can you do better? Why?
We used arrays and linked lists to reach our optimal time complexity of O(n). We don't believe it can be improved beyond O(n) due to the constraints of a linked list, but we can try to create a more optimal O(n) function. This can be done by using more standard library functions of linked lists instead of hardcoding it ourselves. In addition, we can store the neighbor offsets locally instead of depending on a method that could be time inefficient.

5. What is the time complexity of your alternative implementation? Comment the function with its time complexity in your code and write down the time complexity in your write-up.
The time complexity of our alternative implementation is also O(n), but it is a more optimal O(n) with a smaller rate of change. To break this down, the code starts with an array and linked list initialization, which is an O(1) time complexity. Then there is a for loop that loops through flooded_list, initializing coordinates to the array. Because this loops through flooded_list, it has an O(n) time complexity. Then, there is a while loop that runs until the linked list is empty. Within the while loop, the first member of queue is removed with the “poll” method, which has an O(1) time complexity. Then, an array of neighbor offsets are initialized, which has an O(1) time complexity. There is then a for loop nested in the while loop that loops through all of the neighbor offset possibilities. In this for loop, neighbor coordinates are first calculated. Since these are constant arithmetic operations, the time complexity is O(1). Then, new coordinate neighbors are created in an If statement, which has an O(1) time complexity. There is a second if statement where values are entered into the visited array and the neighbor coordinates are added to queue. This has an O(1) time complexity because the program is just adding elements. The for loop overall has an O(1) time complexity because that is the worst case within it. The while loop also has an O(1) time complexity because its code and the for loop within it all have O(1) time complexities. The worst time complexity in the entire code is O(n), making it the overall time complexity. 